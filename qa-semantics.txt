# Object-oriented programming #

Q: You said that JavaScript is an object-oriented language, could you expand
   on that?

A: Indeed, JavaScript is object-oriented. Typically, in object-oriented
   languages, everything is an object (e.g. Python, Scala, Ruby, Eiffel, ...)
   In JavaScript this is not the case, there are both objects and primitives.
   The primitives in JS are numbers, strings, booleans, and the special types
   null and undefined. The objects include `Array`, `Function`, `Date`,
   `RegExp`, `Error`, ... This design decision, by many people considered a
   mistake, was carried over from Java.

   ## Objects ##

   Objects in JavaScript are in fact containers of properties, where each
   property has a name and a value. By assigning a function to a property's
   value, one can add a method to the object. This demonstrates the importance
   of the presence of first-class functions. Objects in JavaScript can be
   compared with untyped hash maps from strings to values from any kind,
   similar to Python's dicts, Ruby's hashes, ... The name of a property can be
   any string, but the quotes can be dropped if the name of the property is a
   valid JavaScript identifier. The quotes are required when the property name
   is a reserved keyword, an empty string, or other strings not constituting
   valid JavaScript identifiers.

   ```JavaScript
   var emptyObject = {};
   var person = {
       name: "Erin",
       age: 28,
       "place-of-birth": "Gibraltar", // hyphens are not allowed in JavaScript identifiers
       walk: function () { return "Do bi do ... walking, walking, walking"; }
   };
   ```

   Property lookup is done via the `.` notation. When the property name is not
   a valid JavaScript identifier, one has to use the bracket notation. Looking
   up a property of which the value is a function, just returns that function.
   To actually invoke it, terminate the expression with `()`.

   ```JavaScript
   person.name; // "Erin"
   person["place-of-birth"]; // "Gibraltar"
   person.walk; // [Function]
   person.walk(); // "Do bi do ... walking, walking, walking"
   ```

   This notation of objects is compact, easy to parse and parse, and has
   become a popular general data-interchange format, called
   [JSON][http://www.json.org/] (JavaScript Object Notation).

   JavaScript has no separate hash map type. Since objects function as hash
   maps, they are often (ab)used as hash maps. Conflating objects with hash
   maps can have some unwanted consequences, see the examples in
   #[monkey-patching].<foot>The next JavaScript standard will contain a
   separate `Map` type.</foot>

   As the keys of an object are required to be strings, any key that isn't a
   string will first be converted to a string. which can cause some surprising
   results. See the following example.

   ```JavaScript
   var z = {};
   z[0] = 3;
   z[0]; // 3
   z['0']; // 3
   z[[0]]; // 3, as [0].toString() == '0'
   ```



Q: Object-oriented programming includes more than "everything is an object".
   What about polymorphism, inheritance, etc.?

A: Of course, OOP is broader than "everything is an object". Most definitions
   of object-oriented programming include features such as modularity,
   encapsulation, polymorphism, inheritance, ...

   JavaScript has support most of them, but differs from other classical OO
   languages in the implementation of these features. Take for instance
   inheritance. Classical OO languages mostly feature a class-based
   inheritance mechanism, whereas JavaScript has prototype-based inheritance.
   JavaScript often has a different way of doing things compared to other
   languages, this will be a recurring theme.

   ## Prototype-based programming ##[proto]

   Q: What entails prototype-based inheritance?

   A: A better term would be prototype-based programming, as inheritance is
      just one ingredient of this style of object-oriented programming.
      Prototype-based programming can easily be explained by comparing it with
      class-based programming.

      In class-based programming, one defines /classes/. Each class consists
      of fields and methods. To use a class, one /instantiates/ a new object
      of the class, which will have the fields and methods defined in the
      class. The values of the fields can differ from object to object. Let's
      make an analogy: the class is the blueprint of the car, and the objects
      are cars built from the blueprint. Now let's throw inheritance in the
      mix. One can define a class that inherits from another class. This new
      class will contain all the fields and methods of the parent class, but
      can add fields and methods, and can also override fields and methods.

      In prototype-based programming, one defines /objects/. Each object will
      consist of fields and methods, or in JavaScript's case, /properties/.
      The whole concept of classes is removed from the equation. Instead of
      defining a blueprint to build new cars with, one just builds a car. But
      does this mean that we have to build every car from scratch, i.e.
      (re)define the fields and methods for every objects we want to use? No,
      to make a new object with the same fields and methods as another object,
      we /clone/ the old object to get a new one. In other terms: we define a
      new object with the old object as /prototype/. Inheritance is also done
      via cloning, but after the cloning, the new object is extended with new
      fields and/or methods, and existing fields and/or methods can also be
      overriden. This new object can, in turn, be used as a prototype for
      other objects.

      Q: Could you show how it's done in JavaScript?

      A: In JavaScript, objects can be created via object literals. In this
         case, `Object` will be their prototype.

         ```JavaScript
         var o = {foo: "bar"};
         // Object.getPrototypeOf(x) returns the prototype of x
         Object.getPrototypeOf(o); // {}, which is an empty Object
         ```

         Another way to create objects in JavaScript, is via the `new`
         keyword, which you probably know from C++, Java, etc. The `new`
         keyword should be followed by a function call. The function after the
         `new` keyword is called the constructor. Objects created this way
         will have their constructor's prototype as their prototype.

         ```JavaScript
         // Car is a constructor
         function Car(make) {
             this.make = make;
         };
         Object.getPrototypeOf(Car); // [Function: Empty] is the prototype of a function
         // Define a new method for Car
         Car.prototype.drive = function() {
             println("Vroom");
         };
         var myCar = new Car("BMW");
         Object.getPrototypeOf(myCar); // { drive: [Function] }, the prototype of Car
         ```

         Notice that the name of the constructor function is capitalised. This
         is a convention carried over from Java.

         Q: If the naming is only a convention, how then differs a constructor
            from a regular function?

         A: It doesn't actually, it's the use of `new` keyword that makes a
            regular function act like a constructor. By prepending this
            keyword to the function invocation, a couple of things happen, see
            #[constructor-invocation].

         Q: If methods are just properties that are functions, why don't you
            just define them in the constructor instead of defining them on
            the prototype? The latter seems more verbose.

         A: If we were to define the methods in the constructor, copies of
            these methods would be created for every object created via the
            constructor. The methods defined on the prototype don't have to be
            copied, but are inherited.

         Here's another example of inheritance in JavaScript.

         ```JavaScript
         // Create a new object that inherits from obj
         function inherit(obj) {
             function f() {}; // Dummy constructor
             // The new object's prototype is obj
             f.prototype = obj;
             // Make the new object
             return new f();
         }
         // Create a new object from scratch
         var a = {x: "a's x"};
         // Create a new object by cloning an existing object
         var b = inherit(a);
         // Change the value of b's x property
         b.x = "b's x";
         // This change only affects b
         a.x; // "a's x"
         b.x; // "b's x"
         ```

      Q: What are the pros and cons of prototype-based programming?

      A: Prototype-based programming gives the programmer more flexibility and
         freedom to define and redefine the fields and methods of objects
         dynamically. Instead of focusing on building a brittle taxonomy of
         classes, as in class-based programming, the focus lies on making a set
         of objects with the desired behaviour, reusing them via cloning, and
         modifying their behaviour when it's required. When building a taxonomy,
         it is often the case that some class at the bottom of the chain
         inherited some unwanted fields or methods, as it is not always possible
         to classify everything in a consistent taxonomy. Prototype-based
         programming gives you the freedom to clone and override the fields and
         methods of other objects at will.

         For example, you have a bunch of `Cat` objects, but you want one of the
         cats, named Dexter, to make a different meow-sound. You can simply
         change the `meow` method of Dexter, a single `Cat` object, without
         affecting the others, or having to define a new subclass of `Cat`.

         Having so much control over which fields and methods to /inherit/ allows
         the programmer to do things not possible in class-based languages
         without language support, for instance traits can easily be emulated
         using prototype-based programming. Even classes can be and often are
         emulated.

         Let's show you how to emulate classes using prototypes:

         ```JavaScript
         function Car(make) {
             this.make = make;
         };
         Car.prototype.drive = function() {
             println("Vroom");
         };
         // Constructor for the subclass SportsCar
         function SportsCar(make) {
             this.make = make;
         };
         // The prototype of SportsCar is a regular Car
         SportsCar.prototype = new Car;
         // We change the constructor, because we inherited Car's constructor
         SportsCar.prototype.constructor = SportsCar;
         SportsCar.prototype.driveFast = function() {
             this.drive(); this.drive();
         };

         // Instantiate a new SportsCar
         var mySportsCar = new SportsCar("BMW");
         mySportsCar.driveFast();
         // Vroom
         // Vroom
         ```

         The steps to create a subclass are often put together in a single
         function, allowing easy class-based inheritance.

         Traits are also easy to emulate, although we don't have access to the
         super objects anymore. Abstract members can also be emulated, but will
         not be checked at compile-time for presence.

         The methods are simply copied over from the trait object to the other
         object.

         ```JavaScript
         // The Trait we define
         var HasTires = {
             tiresOk: true,
             puncture: function() {
                 this.tiresOk = false;
             }
         };
         // Add the properties of the trait to the prototype of obj
         var mixin = function(obj, trait) {
             for (var prop in trait) {
                 obj.prototype[prop] = trait[prop];
             }
         };
         // We'll continue with the SportsCar defined above
         mixin(SportsCar, HasTires);
         // The already defined mySportsCar now has the functionality defined in
         //  the HasTires trait
         mySportsCar.puncture();
         mySportsCar.tiresOk; // false
         ```

         Of course, freedom comes with a price. One of the disadvantages are the
         slower field and method accesses/dispatches and to a lesser extend the
         memory overhead. Objects cloned from others object don't clone the
         fields and methods. It would be wasteful to clone this reusable data.
         Instead, the cloned object keeps track of its prototype. Whenever an
         inherited field or method of the new object, i.e. a field or method
         defined in the prototype (or a prototype of the prototype), is accessed,
         the new object delegates the call to the prototype. This delegation will
         go on until a definition is found in one of the ancestor prototypes. The
         longer this /chain/ of prototypes, the costlier a field access or method
         call.

         Another disadvantage is that it becomes harder to figure out which
         fields and methods an object has, and where they were defined. When
         using classes, knowing the class of an object is enough to know which
         fields and methods an object has (this, of course, includes looking
         at superclasses). A class functions as the type of the object, but in
         JavaScript, properties can be added and removed from objects at
         run-time.


   ## Invoking functions ##[func-invocation]

   In JavaScript, a function can be invoked in four different ways:

   * As a function
   * As a method
   * As a constructor
   * Indirectly through `call()` or `apply()`

   Functions can behave differently, depending on the kind of invocation. For
   instance the value of `this`, will be different. In JavaScript, as in most
   object-oriented languages, `this` is a special keyword inside the context
   of a function that refers the object of which the function is a method,
   i.e. the owner of the method.

   ### Function invocation ###

   Function invocation, is the regular kind of invocation, like you would call
   functions (or procedures) in C, Haskell, or Lisp, i.e. in a non-OO
   language.

   For example:

   ```JavaScript
   function add(x, y) {
       return x + y;
   }
   ```

   Functions that don't contain an explicit `return`-statement, will return
   `undefined`, JavaScript's `void`.

   In the case of a regular function invocation, the value of `this` will be
   the global object. See #[scope] and #[modularity] for more about the global
   object.

   ### Method invocation ###

   A function is considered a method when it's the property of an object. The
   big difference between function and method invocation, is that in the case
   of method invocation, `this` will refer to the object on which the method
   is called, instead of the global object.

   ```JavaScript
   function f() {
       return this.x;
   }
   // Function invocation
   var x = 1;
   f(); // 1
   // Method invocation
   var o = {x: 2, f: f};
   o.f(); // 2
   ```

   ### Constructor invocation ###[constructor-invocation]

   When a function or method invocation is preceded by the `new` keyword, it
   is a constructor invocation.

   A few things are different for constructor invocations:

   * A new object is created and will be accessible via `this`.
   * The prototype of the constructor function is stored as the prototype of
     the new object.
   * The newly created object is automatically returned at the end of the
     function call, no explicit `return` is required.
   * When the constructor has no parameters, the parentheses after the
     function name are optional. E.g. `new Object()` vs `new Object`.

   Q: So you're saying, every function can be invoked as a constructor? What
      is the point of that?

   A: The ability to invoke every function as a constructor isn't very useful.
      The `new` keyword is rather dangerous, certainly when it's forgotten.
      Not prepending a constructor call with `new` will cause the properties
      defined in the function to be added to the global object instead of a
      newly created object. A reason for the inclusion of the `new` keyword is
      the familiarity from other object-oriented languages. And, of course,
      there still has to be a way to create a new object.

   ### Indirect invocation ###[indirect-invocation]

   The fourth and final kind of invocation, is indirect invocation. As
   `Function`s are also `Object`s in JavaScript, they can have methods. Two of
   the available methods of `Function`s are `call` and `apply`.<foot>For
   readers familiar with Common Lisp (or a [Lisp-2][lisp2] to be more
   precise), `call` is JavaScript's `funcall`. For readers familiar with any
   Lisp dialect, JavaScript's `apply` is similar to most Lisp's
   `apply`.</foot>

   [lisp2]: http://en.wikipedia.org/wiki/Lisp-1_vs._Lisp-2#The_function_namespace

   The `call` method is invoked on a function and takes at least one argument,
   the object to which `this` will refer in the context of the function. Extra
   arguments are passed to the function.

   The `apply` method is invoked on a function and takes at least one
   argument, the object to which `this` will refer in the context of the
   function. The optional second argument should be an `Array`, holding
   arguments that will be to the function.

   ```JavaScript

   function f(x, y) {
       return [this, x, y];
   }
   f.call({a: 'foo'},  1, 2); // [ { a: 'foo' }, 1, 2 ]
   f.apply({a: 'foo'}, [1, 2]); // [ { a: 'foo' }, 1, 2 ]
   ```

   Q: Can you give me a use case of these `call`- and `apply`-methods?

   A: A possible use case is the reuse of methods. Let's say we have an object
      (or a class) A with some methods. We also have some other, totally
      unrelated object B. There might be a method defined on A that we wish to
      invoke on B too, instead of copying the method from object A to object
      B, or making A B's prototype, we can simply invoke the method on object
      B.

      Essentially, we bypass the inheritance tree, and are able to reuse
      methods defined for other objects.

      ```JavaScript
      // Object/Class A
      var Person = function(name) { this.name = name; };
      Person.prototype.introduce = function() {
          return "Hello, my name is " + this.name;
      };
      // Object B. We don't want B to inherit from A. We could add the
      // `introduce`-method as a property to B, but indirect invocation is much
      // cheaper that copying the method, and then performing a method
      // invocation.
      var car = {name: 'Mater', town: 'Radiator Springs'};
      Person.prototype.introduce.call(car);
      ```

   ## Encapsulation ##[encapsulation]

   Another example of JavaScript's /exotic/ way of doing things is
   encapsulation. Most classical OO languages support visibility modifiers to
   control the accessibility of fields and methods by other classes. In
   JavaScript, there are no such modifiers, but encapsulation is still
   achievable, via the use of closures.

   Example:

   ```Java
   class A {
       private int counter = 0;
       public void inc() {
           counter++;
       }
   }
   ..
   A a = new A();
   a.inc(); // OK
   a.counter; // Error: not visible!
   ..
   ```
   ```JavaScript
   var a = (function () {
       var counter = 0;
       return {
           inc: function() {
               counter++;
           },
       };
   })();
   a.inc(); // OK
   a.counter; // Error: not visible!
   ```


   Q: What is a closure?

   A: Before explaining what a closure is, you have to know some things about
      JavaScript's scoping rules.

      ### Function & global scope ##[scope]

      JavaScript's scoping rules differ from common languages like C and Java.
      In C and Java, curly braces (`{...}`) delimit different scopes. The body
      of a function, a while-loop, a for-loop, a class (in the case of Java),
      all have a separate scope (known as /block scope/). In JavaScript, there
      are only two kinds of scope: the global scope and function scope.

      Let's see some examples of these differing scoping rules

      ```Java
      for (int i = 0; i < 10; i++) {
          // ...
      }
      System.out.println(i); // Error: i is undefined here,
      // it is only accessible within the scope of the for-loop

      int a = 10;
      {
          // A new scope
          a = 3;
      }
      System.out.println(a); // 10
      ```

      ```JavaScript
      for (var i = 0; i < 10; i++) {
          // ...
      }
      println(i); // 10

      var a = 10;
      {
          // No new scope
          a = 3;
      }
      println(a); // 3
      ```

      By default all variables will be defined in the global scope, i.e. they
      will be global variables. This sends cold shivers down many a
      programmer's spine. The only way to delimit the scope of variable
      definitions is by wrapping them in a function.

      ```JavaScript
      var x = 3;
      (function() {
          var x = 10;
          // x = 10
      })(); // This function is invoked immediately after definition
      println(x); // 3
      ```

      ### Variable hoisting ###[hoisting]

      In this intermezzo, another peculiarity of JavaScript's scoping rules is
      introduced, /variable hoisting/.

      ```JavaScript
      var f = function() {
          return y;
      };
      // ...
      var y = 3;
      f(); // 3
      ```

      In the example above, we define the function `f` which returns the value
      of the undefined variable `y` when called. A bit later in the program,
      but still in the same scope (global or function), we define the variable
      `y`. Finally, we invoke `f`, which returns `3`. Shouldn't the definition
      of `f` fail with an error message complaining about the undefined
      variable `y`? What actually happens, is that all variable declarations
      in the current scope are moved to the beginning of the scope. Only the
      declarations, not the initialisations.

      What happens under the hood is the following:

      ```JavaScript
      var f, y;
      f = function() {
          return y;
      };
      // ...
      y = 3;
      f(); // 3
      ```

      In this case, some people might consider variable hoisting to be
      advantageous, but that's not always the case, see the following example:

      ```JavaScript
      var x = 0;
      function f() {
          println("A: " + x);
          var x = 1;
          println("B: " + x);
      }
      f();
      // A: undefined
      // B: 1
      ```

      Most programmers would expect the first `println`-statement to print out
      `A: 0`. What actually happens is the following:

      ```JavaScript
      var x = 0;
      function f() {
          var x; // x is now declared, but uninitialised, i.e. `undefined`
          println("A: " + x);
          x = 1;
          println("B: " + x);
      }
      f();
      ```

      This phenomenon is called /variable hoisting/. The variable declarations
      are hoisted to the top of the scope, but the initialisations are left in
      place.

      Q: Why does JavaScript do this?

      A: We explained this in the answer to the question about
         #[line-by-line].

      ### Lexical & dynamic scope ###

      We assume you're already familiar with lexical and dynamic scoping, so
      we'll quickly glance over it.

      In the case of lexical scoping, functions are invoked in the scope that
      was active during the definition of the function. In the case of dynamic
      scoping, functions are invoked in the scope active during the invocation
      of the function. Let's show difference with an example.

      ```JavaScript
      var f = (function() {
          var z = 'lexical';
          return function() {
              return z;
          };
      })();

      var z = 'dynamic';
      f(); // 'lexical' when lexically scoped,
           // 'dynamic' in the other case
      ```

      JavaScript is lexically scoped, as is Scheme, one of JavaScript's
      biggest [influences][influences]. The return value of `f` in the example
      above will be 'lexical'.

      ### Closures ###[closures]

      Let's have another look of the example that we showed you to demonstrate
      encapsulation.

      ```JavaScript
      var a = (function () {
          var counter = 0;
          return {
              inc: function() {
                  counter++;
              },
          };
      })();
      a.inc(); // OK
      a.counter; // Error: not visible!
      ```

      As JavaScript is lexically scoped, functions have to capture the scope
      that was active during their definition. Essentially, what happens is
      that all variables defined in a scope outside the defined function but
      referenced from within the scope of the function, known as /free
      variables/, have to be captured. In the example above, the function
      defined on line 4 references a variable `counter` (line 5), that was
      defined in another scope (line 2). The free variables are /closed/-over,
      they are /captured/ by the closure. One can think of a closure as a pair
      of a function, i.e. code, and its environment, i.e. data.

      Encapsulation can be achieved by defining the variables meant to be
      private in a function (scope) A, and defining a new function B within A,
      that references these variables. The closure of function B will capture
      these private variables. By holding onto function B, but discarding
      function (scope) A, only B will be able to access these private
      variable,<foot>Unless function B leaks them via its properties.</foot>
      effectively achieving encapsulation.

      The following example<foot>Taken from the [Dart Language
      Tour][dartlangtour].</foot> demonstrates a common pitfall with closures
      (and scope) in JavaScript:

      [dartlangtour]: http://www.dartlang.org/docs/dart-up-and-running/ch02.html#for-loops

      ```JavaScript
      var closures = [];
      for (var i = 0; i <= 1; i++) {
          var f = function() { println(i); } // f will print i when invoked
          closures.push(f);
      }
      closures[0](); // 2, why not 0?
      closures[1](); // 2, why not 1?
      ```

      What happens is that the /variable/ is captured by the closure, not the
      /value/ of the variable during the capture. Because JavaScript has no
      separate scope for the body of a for-loop, the variable `i` is in scope
      during the whole example. The for-loop stops when variable `i` is
      greater than `1`, i.e. `2`, this explains why both closures print the
      number `2`.

      The solution to this problem is to wrap the definition of `f` in another
      function which takes the variables that will be captured as arguments,
      effectively creating a new scope/closure, and invoking it immediately
      with the variable to capture as argument. Function arguments are passed
      by value, not by reference.

      ```JavaScript
      var closures = [];
      for (var i = 0; i <= 1; i++) {
          var f = (function(i) {
              return function() {
                  println(i);
              };})(i);
          closures.push(f);
      }
      closures[0](); // 0
      closures[1](); // 1
      ```



   Q: What are the advantages of implementing encapsulation via closures?

   A: Actually, one could call it /emulating/ encapsulation via closures.
      Because of the absence of built-in encapsulation via
      visibility-modifiers, JavaScript programmers are required to implement
      encapsulation manually via closures. So one could call it a disadvantage
      of JavaScript, although some people argue against encapsulation.

      With closures, the programmer has more control over encapsulation, but
      has to do more work to achieve it.



   ## Polymorphism ##

   Polymorphism in JavaScript is achieved through inheritance or duck typing.

   Example of polymorphism through inheritance:

   ```JavaScript
   // Superclass Animal
   var Animal = function(name) { this.name = name; };
   // Default implementation of makeNoise
   Animal.prototype.makeNoise = function() { return "Silence"; };

   // Subclass Dog
   var Dog = function(name) { this.name = name; };
   Dog.prototype = new Animal();
   // Override makeNoise
   Dog.prototype.makeNoise = function() { return "Bark"; };

   // Subclass Turtle
   var Turtle = function(name) { this.name = name; };
   // Don't override makeNoise
   Turtle.prototype = new Animal();

   var animals = [new Dog("Pluto"), new Turtle("Jeffrey")];

   for (var i = 0; i < animals.length; i++) {
       println(animals[i].makeNoise());
   }
   // Bark
   // Silence
   ```

   Example of polymorphism through duck-typing:

   ```JavaScript
   var Dog = function(name) {
       this.name = name;
       this.makeNoise = function() { return "Bark"; };
   };

   var Turtle = function(name) {
       this.name = name;
       this.makeNoise = function() { return "Silence";};
   };

   var animals = [new Dog("Pluto"), new Turtle("Jeffrey")];

   for (var i = 0; i < animals.length; i++) {
       println(animals[i].makeNoise());
   }
   // Bark
   // Silence
   ```

   >[Wikipedia on Duck typing][wiki-duck-typing] Duck-typing is a style of
   dynamic typing in which an object's methods and properties determine the
   valid semantics, rather than its inheritance from a particular class or
   implementation of a specific interface.

   [wiki-duck-typing]: http://en.wikipedia.org/wiki/Duck_typing

   In the example above, all objects have the required `makeNoise` function
   as a property, thus satisfy the required /semantics/.

   Q: Which of the two is preferable, polymorphism through inheritance, or
      through duck typing?

   A: To obtain polymorphism through inheritance, you have to set up the
      inheritance relation, including boilerplate code (constructors, method
      prototypes, ...). This requires more work from the programmer. The
      advantage of this approach is that the methods can be inherited from
      prototypes of objects, requiring less memory than storing a method for
      each object.

      Not having to set up the inheritance relation, is one of advantages duck
      typing. It's sufficient to add the appropriate methods to the objects
      that will participate in this application of polymorphism.

   Q: You mentioned that one can /override/ a method in JavaScript, is it also
      possible to /overload/ a method in JavaScript?

   A: To be clear, a method (or function) overloads another method if it has
      the same name, but differs in the number of arguments or the types of
      the expected arguments. The right method to call is chosen statically,
      at compile-time. Overloading is a feature typically present in
      statically typed languages. With JavaScript being a dynamically typed
      language, the compile-time resolution that determines which method to
      call is ruled out, as the types are not known in advance.

      ## Function arguments ##

      Overloading based on arity is possible in dynamically typed languages,
      but not in JavaScript. The reason being that JavaScript doesn't check
      whether a function is called with the correct number of arguments.
      JavaScript will happily allow you to call a function expecting two
      arguments with 0, 1, 2, 3, ... arguments. Missing arguments will be
      `undefined`. JavaScript also allows you to access the excess arguments
      via the `arguments` object. The `arguments` object is a local variable
      accessible within all functions. It is similar to an Array, but not
      quite the same. The elements of `arguments` can be accessed, and it has
      the `length`-property, but the other methods available for `Array`s
      cannot be used on the `arguments` object. One can convert the
      `arguments` object to an actual array, by calling `Array`'s
      `slice`-method on it, like so: `var args =
      Array.prototype.slice.call(arguments);`.<foot>The `slice`-method of
      `Array` copies the elements into a new array, it optionally takes start-
      and end-indexes. See #[indirect-invocation] for more about the
      `call`-method.</foot>

      Q: What's the point of this `arguments` object? And why isn't it a
         proper `Array`?

      A: The `arguments` object allows the programmer to define methods
         expecting a variable number of arguments.

         Example:

         ```JavaScript
         // Sums all its arguments. The argument list is empty, because we'll
         // use the arguments object.
         function addAll() {
             var args = Array.prototype.slice.call(arguments);
             var total = 0;
             // args.shift() removes the first element from the array, and
             // returns that element.
             while (args.length > 0) total += args.shift();
             return total;
         }
         ```

         Even when expecting a fixed number of arguments, the programmer can
         benefit from access to the `arguments` object. For instance when
         implementing a decorator.

         ```JavaScript
         function decorate(toDecorate, decorator) {
             return function() {
                 // Both the decorator and the function to decorate can be
                 // called with the same arguments.
                 decorator.apply(null, arguments);
                 return toDecorate.apply(null, arguments);
             };
         };

         function argsPrinter() {
             var args = Array.prototype.slice.call(arguments);
             println("Arguments: " + args.join(", "));
         };

         function add(x, y) { return x + y; };

         decorate(add, argsPrinter)(1, 2);
         // Arguments: 1, 2
         // => 3
         ```

         The reason that the arguments object isn't a proper `ArrayÂ´, is
         /probably/ the following:

         >[CMS's answer on StackOverflow][CMS-SO] The concept of the
         `arguments` object has been on the language since the very beginning,
         it's even described in the ECMAScript First Edition Standard. In that
         version of ECMAScript, the `Array.prototype` was really basic, array
         objects contained /only 4 methods/: `toString`, `join`, `reverse` and
         `sort`. I think that's one of the major reasons about they make
         `arguments` to inherit from `Object.prototype`, at that time those
         `Array` methods didn't look too /useful/. But the `Array.prototype`
         object was extended in the next versions of the standard, now on ES5,
         `Array` objects have methods such as `map`, `reduce`, `every`,
         `some`, etc, that are /really powerful/. [...]

         [CMS-SO]: http://stackoverflow.com/a/3242693


      JavaScript's loose call convention, and the presence of the `arguments` object
      allows the programmer to emulate overloading by doing the resolution at
      run-time.

      Example:

      ```Java
      void overloaded() { return "No args"; }
      void overloaded(int x) { return "A number"; }
      void overloaded(String x) { return "A string"; }
      void overloaded(int x, String y) { return "A number and a string"; }
      ```

      ```JavaScript
      function overloaded(arg1, arg2) {
          // One could also use an if-then-else construction
          switch (arguments.length) {
          case 0: return "No args"; break;
          case 1: switch (typeof(arg1)) {
                  case 'number': return "A number"; break;
                  case 'string': return "A string"; break;
                  }
                  break;
          case 2: if (typeof(arg1) == 'number' && typeof(arg2) == 'string')
                      return "A number and a string";
          }
      }
      // Identical for the Java program
      overloaded();
      // No args
      overloaded(1);
      // A number
      overloaded("foo");
      // A string
      overloaded(1, "foo");
      // A number and a string
      ```

      These `return`-statements could of course be replaced with different
      blocks of code, specific for each case.

      Of course, doing this resolution at run-time has a negative impact on
      the performance.



   ## Modularity ##[modularity]

   An important cornerstone of object-oriented programming is code reuse. In
   order to reuse code, it's helpful, or rather often, of paramount importance
   to organise code into modular components. We'll use the term /module/ for
   such a modular component. Such modules should provide a clear interface of
   the offered functionality, as well as the required functionality.

   Modules often function as a namespace, take for example a look at Java,
   where packages or classes act as modules.

   Originally, JavaScript was intended to augment static web pages with little
   scripts, making the page more dynamic. JavaScript was designed with this
   goal in mind. Little scripts don't need namespaces, packages, or modules.
   They were often thrown together in a single file. As we saw in #[scope],
   variables and functions defined outside the context of a function, become
   global variables. Every script executed on a web page executes in the same
   context, the global object. This object is directly accessible via the
   `window` variable, the name of this object immediately reveals JavaScript
   tight coupling with the browser. All globals are properties of this
   `window` object.

   ```JavaScript
   var x = 3;
   x; // 3
   window.x; // 3
   ```

   This global object is the default namespace. Imagine loading some
   third-party scripts, for example scripts that add ads to your website. They
   will be executed in the same context as your own scripts. They can call
   into your code, or override your functions when names conflict. Not only is
   the global object a problem in terms of namespacing and modularisation,
   it's also a security issue.

   JavaScript has no concept of a module or any language features for
   namespacing. But, as we saw a couple of times already, JavaScript provides
   sufficient means to emulate them.

   The construct we'll use to emulate a module is a closure (see #[closures]).
   Recall that we emulated #[encapsulation] via closures. A closures provides
   us with two useful ingredients: /privacy/ and /state/. We have control over
   the visibility of the variables declared in the scope of the closure, as
   well as their state.

   By wrapping the code constituting the module in a closure, we prevent it
   from tainting the global namespace. Forgetting the `var` keyword will still
   create global variables though, see #[variables-functions].

   ```JavaScript
   (function() {
       var x = 3;
       var _privateVar = 1;
       var f = function(a) { return a * a; };
       // Here come other variables and function definitions
       // ...
   })();
   f(x); // ReferenceError: f is not defined
   ```

   Currently, the functionality of our module is only accessible inside the
   module. The next thing to do is to export the functionality so it can be
   used by other modules. This is accomplished by letting the closure return
   an object containing the exported variables and functions. This object acts
   as a namespace for the exported functionality of the module. These
   namespace can be nested, by embedding other namespace objects inside them.

   ```JavaScript
   var myModule = (function() {
       var module = {};
       module.x = 3;
       var _privateVar = 1; // Not exported
       module.f = function(a) { return a * a; };
       // Here come other variables and function definitions
       // ...
       return module;
   })();
   myModule.f(myModule.x); // 9
   ```

   To use functionality from other modules, we just pass the module object as
   an argument to the closure.

   ```JavaScript
   var otherModule = (function(m) {
       var module = {};
       module.f = function(a) { return m.f(a) * a; };
       return module;
   })(myModule);
   otherModule.f(myModule.x); // 27
   ```

   This approach is also known as the /Module Pattern/.

   #[nodejs] employs a similar approach, albeit with less boilerplate code.
   There is a one-to-one mapping of files to modules. The code of every file
   are executed in a separate context, preventing them from tainting the
   global namespace. To actually export variables or functions, they have to
   be attached to `exports`-object. The `exports`-object is a free variable
   within the context of each file. To use the functionality of another
   module, one has to `require` the file containing the module. The result of
   this call to the `require`-function returns the `exports`-object of the
   corresponding module.

   ```NodeJS
   // File a.js
   var x = 3;
   exports.f = function(a) { return x + a; };
   // File b.js
   var a = require('a.js');
   a.f(5); // 8
   ```

# Dynamic typing #[dynamic-typing]

Q: What kind of typing discipline does JavaScript have?

A: Unlike for instance Java, a language people would believe to be akin to
   JavaScript when comparing their names, JavaScript isn't statically typed,
   but dynamically typed.

   The types of /variables/ aren't known at /compile/-time, but the types of
   the /values/ are known at /run/-time. Programmers don't have to annotate
   functions and variables with types like in statically typed
   programs.<foot>In statically typed languages with /type inference/, e.g.
   ML, Haskell, ... it is also not required to declare the types.</foot>

   Q: Why did JavaScript's creator choose to make JavaScript dynamically
      typed?

   A: As mentioned before, JavaScript's creator, Brendan Eich, based
      JavaScript on Scheme, which is a dynamically typed language.

      JavaScript was intended to be a quick and easy scripting language.
      Advocates of dynamic typing suggest that programmer productivity is
      increased, at least for small to medium size programs, when the
      programmer doesn't have to figure out the types when writing the
      program.

      Even though static typing has many advantages, like better
      documentation, the elimination of type errors at run-time,<foot>Most
      (static) type systems are actually unsound and cannot guarantee a
      program is well-typed in all of the cases. For instance /casting/ in
      Java and C is a totally unsafe operation. Even Haskell, a language with
      an advanced type system, has an unsafe function that bypasses the type
      system: `unsafePerformIO`.</foot> correct auto completion of identifiers
      during development, ... it would be very hard to make JavaScript
      statically typed.

      The ability to extend (prototypes of) objects with new properties at
      run-time, the ability to change the prototype of an object at run-time,
      the way the `arguments`-object works, or even the `eval` function (see
      the next paragraph) will make a static type system for JavaScript very
      complicated, or in the case of `eval`, impossible.

      There is one built-in function present in JavaScript that is impossible
      to annotate with a useful type signature, `eval`, which comes from Lisp.
      This function takes a string and evaluates it, effectively parsing and
      interpreting it.<foot>If someone wanted to statically compile JavaScript
      *and* include `eval`, a JavaScript interpreter would have to be included
      in the executable.</foot> The `eval` function is also a security risk
      and should not be called with input from third-parties. Using `eval` in
      a program is often frowned upon.<foot>A plausible use of `eval` is to
      build a REPL (Read-Eval-Print-Loop).</foot>


   ## Weak typing ##[weak-typing]

   JavaScript's type system is also /weakly/ typed. The opposite of weak
   typing is, /strong/ typing. In weakly typed programs, types can be
   implicitly converted to other types, whereas these conversion have to be
   done explicitly in strongly typed language.

   An example will make it much clearer:

   ```JavaScript
   "12" * 3; // 36
   ```

   ```Java
   "12" * 3; // Type Error
   Integer.parseInt("12") * 3; // 36
   ```

   In the JavaScript example, `12`, a string, is implicitly converted to a
   number to be able to multiply it with `3`. In strongly typed languages,
   such as Java, the conversion of string to number has to be done explicitly.

   Q: This looks like a useful feature to me, why aren't most languages weakly
      typed?

   A: In the example above, it indeed seems useful. This is not always the
      case. It's not always obvious when a conversion and which conversion
      will occur. Take the following example:

      ```JavaScript
      ('10' - 1) * 2; // 18 = 9 * 2
      ('10' + 1) * 2; // 202 = 101 * 2
      ```

      `Object`s and `Array`s can also cause some odd interactions:

      ```JavaScript
      [] + 1; // "1"
      {} + 1; // 1
      [] + []; // ""
      [] + {}; // "[object Object]"
      {} + []; // 0
      {} + {}; // NaN
      ```

      Source: [Gary Bernhardt's talk, "WAT"][wat]

      [wat]: https://www.destroyallsoftware.com/talks/wat

      TODO ^^ doesn't work properly in the browser

      This is the downside of these conversions, you have to know when they
      will occur and which conversion will occur for which types. Looking at
      the examples, you will probably agree that these rules aren't really
      intuitive.


   ## Equality ##

   Like most programming languages, JavaScript has a `==` operator to check
   whether two values are equal, its inverse, `!=` is also present. JavaScript
   also has another operator that checks whether two values are equal, `===`,
   and of course, its inverse, `!==`. The latter operator, `===`, is also
   called the /strict/ equality or /identity/ operator. The two operators
   define /equality/ in a different manner.

   The strict equality operator, `===`, compares two values as follows:

   * If the two values have different types, they are not equal.
   * If both values are `null` or both values are `undefined`, they are equal.
   * If both values are the boolean value `true` or both are the boolean value
     `false`, they are equal.
   * If one or both values is `NaN`, they are not equal. The `NaN` value is never
     equal to any other value, including itself! To check whether a value `x` is
     `NaN`, use `x !== x`. `NaN` is the only value of `x` for which this expression
     will be true.
   * If both values are numbers and have the same value, they are equal. If
     one value is `0` and the other is `-0`, they are also equal.
   * If both values are strings and contain exactly the same 16-bit values
     (see the sidebar in Text) in the same positions, they are equal. If the
     strings differ in length or content, they are not equal.
   * If both values refer to the same object, array, or function, they are
     equal. If they refer to different objects they are not equal, even if
     both objects have identical properties.

   The (non-strict) equality operator, `==`, compares two values as follows:

   * If the two values have the same type, test them for strict equality as
     described above. If they are strictly equal, they are equal. If they are
     not strictly equal, they are not equal.
   * If the two values do not have the same type, the `==` operator may still
     consider them equal. Use the following rules and type conversions to
     check for equality:
     * If one value is `null` and the other is `undefined`, they are equal.
     * If one value is a number and the other is a string, convert the string
       to a number and try the comparison again, using the converted value.
     * If either value is `true`, convert it to `1` and try the comparison again.
       If either value is `false`, convert it to `0` and try the comparison again.
     * If one value is an object and the other is a number or string, convert
       the object to a primitive. An object is converted to a primitive value
       by either its `toString()` method or its `valueOf()` method. The
       built-in classes of core JavaScript attempt `valueOf()` conversion
       before `toString()` conversion, except for the `Date` class, which
       performs `toString()` conversion.
     * Any other combinations of values are not equal.

   Source: #[Flanagan]

   The following table illustrates the rules of the strict equality operator,
   `===`.

   <html><table class="comparisons" id="strict-equality-table"></table></html>


   And the following table illustrates the rules of the non-strict equality
   operator, `==`.

   <html><table class="comparisons" id="equality-table"></table></html>

   Tables adapted from [dorey's JavaScript-Equality-Table][githubEqTable].

   [githubEqTable]: https://github.com/dorey/JavaScript-Equality-Table


   ## `undefined` & `null` ##[undefined-null]

   Most (object-oriented) languages have a special value, `null`, a.k.a. the
   /null pointer/, which is used to indicate the absence of a value. Whenever
   a variable is expected to be a pointer or an object, i.e. has a reference
   type, it can contain the `null` value, meaning that the variable has no
   value. This null pointer is the cause of many errors, as the programmer
   should verify whether a reference isn't a null pointer before using
   it.<foot>C.A.R. Hoare, the inventor of the null reference, calls it his
   "billion-dollar mistake".</foot><foot>A safer alternative is a nullable
   type, like Haskell's `Maybe` type or Scala's `Option` type.</foot>

   Allowing null pointers in a language is commonly regarded as a source of
   problems. Of course, JavaScript can do better than this, it has two
   different special values that are essentially null pointers! The first one
   is `null`, the regular null pointer, which indicates the absence of a
   value. `null` is a special keyword in the JavaScript. The second one is
   `undefined` indicates that a value is not initialised, e.g. the value of
   missing parameters, undefined methods, missing properties of an `Object`,
   missing elements of an `Array`. In older versions of JavaScript `undefined`
   was a global value, which could even be changed! Changing the value of the
   global `undefined` value could break whole programs. Luckily, this mistake
   was corrected in later versions. The type of `null` is `object`, in a way,
   this makes sense, because `null` takes the place of an absent `object`. The
   type of `undefined` is `undefined`.

   Q: Why make a difference between these two? When a property is `undefined`,
      isn't it the same as the absence of the value of this property?

   A: It's hard to conceive of a convincing argument for a separation between
      the two. Here's the one Douglas Crockford makes in #[Crockford]:

      >[Douglas Crockford][Crockford] You might consider `undefined` to
       represent a system-level, unexpected, or error-like absence of value
       and `null` to represent program-level, normal, or expected absence of
       value. If you need to assign one of these values to a variable or
       property or pass one of these values to a function, `null` is almost
       always the right choice.


   ## Truthiness and falsiness ##

   JavaScript has a `boolean` type of which there exist two values, `true` and
   `false`. These two values, or expressions that evaluate to one of them can
   be used as conditions of an if-statement, or any other /boolean
   context/.<foot>Expressions used as operands of a boolean operator are also
   in a boolean context, e.g. `1 && true == true`.</foot> In JavaScript,
   values of all types can, not just boolean, can be used in a boolean
   context. All values can be converted to a boolean, depending on the
   /truthiness/ or /falsiness/ of the value. All values are considered to be
   /truthy/, including `Object`s, `Array`s, numbers, except for the following
   list of values which are /falsy/:

   * `undefined`
   * `null`
   * `0`
   * `-0`<foot>See #[numbers] for more about `Number`s. `0` is equal to `-0`!
     To distinguish between these two values, you can use the following tests:
     `1 / 0 == Infinity`, `1 / -0 == -Infinity`.</foot>
   * `NaN`
   * `""`

   The concept of truthiness and falsiness comes from Lisp-like languages.

   Q: Is this something one shouldn't rely on, such as these type conversions?

   A: This actually proves to be useful in most cases. With one check, you can
      quickly cover the most common edge cases. If you're working with strings
      or numbers, you still have to pay attention to `0` and `""`, see the
      following example:

      ```JavaScript
      function g(x, y) {
          if (x && y)
              return x + y;
          else
              return -1;
      }
      g(4, 5); // 9
      g(4, 0); // -1
      ```

      The programmer could have had the following behaviour in mind when
      writing the function `g` in the example above: "when both arguments are
      non-`null` and also not `undefined`, return the sum of them." This, of
      course, will not function correctly as `0`, a falsy number, will fail
      the check. You can see that it's easy to overlook this subtlety.

# Functional programming #[functional]

Q: You mentioned that JavaScript has first-class functions, does this mean
   that JavaScript is a functional language?

A: It's true that all, functional languages support first-class functions, but
   this alone doesn't make a language functional. Functional programming
   consists of more than just first-class functions, sometimes it's more about
   what you /can't/ do<foot>In Haskell, for example, you can't just change the
   value of a variable.</foot>, or in some cases, what the default
   is.<foot>Immutable data structures are the default in Scala, but mutable
   ones are also available.</foot>

   An important tenet of functional programming is the avoidance or isolation
   of side-effects. All forms of state are side-effects. In JavaScript, pretty
   much every accessible variable can be modified, effectively making the
   whole environment /stateful/. It's very common to define and change global
   variables, even by [accident][variables-functions]. The properties of
   objects are mutable by default, including the methods and the prototype.
   Just like Ruby, JavaScript is a very dynamic language, offering the
   programmer nearly maximum flexibility, at the cost of the omnipresent
   fragility of state.

   ## Immutability ##

   An important tool to minimise the presence of state in a program is the use
   of immutable data structures, instead of mutable ones, which are inherently
   stateful. Rather than modifying the data structure in-place, a new copy of
   the data structure is made with the desired modifications.<foot>Copying the
   whole data structure for every change is of course costly. Luckily,
   efficient immutable data structures exist, for example the /hash array
   mapped trie/, invented by the late Phill Bagwell. See #[Okasaki], for more
   such data structures.</foot>

   It might come as a surprise, but in JavaScript, properties can be made
   immutable. As you will see, this requires a lot more effort. This clearly
   indicates the language designer's intention, to discourage users from using
   the feature.

   Q: How do you mean, "This clearly indicates the language designer's
      intention, to discourage users from using the feature"?

   A: When doing something in a particular way requires more code than in the
      default way, and thus more effort, programmers will not be inclined to
      make the extra effort, and will quickly fall back to the default way.


   Here's how to make a property immutable:

   ```JavaScript
    var obj = {x: 1};
    // Make obj's x property immutable
    Object.defineProperty(obj, 'x', {
        writable: false
    });
    obj.x = 3;
    obj.x; // 1
   ```

   You can still assign a new value to the property, it just won't have any
   effect. Of course, this in now way comes close to Haskell's, Scala's or
   Clojure's immutable data structures.

   In JavaScript 1.8.5, there is a new method available for `Object`s, called
   `freeze`, which effectively makes an object immutable.


   ## Higher-order functions, recursion & lists ##

   If there even was an accepted definition of functional programming,
   JavaScript probably wouldn't satisfy the requirements, but this won't
   prevent programmers from writing JavaScript programs in a functional style.
   JavaScript is in fact a multi-paradigm language, that supports
   object-oriented, functional, and imperative styles. Thanks to Scheme's
   influence, JavaScript is equipped with first-class functions, which allow
   the programmer to write some of the typical higher-order functions that are
   almost invariably present in a functional language.

   Disclaimer: the following functions are in no way optimised or robust
   enough for general use, they just serve to illustrate programming in a
   functional style.

   Let's start off with some primitives, they should be familiar to
   programmers that have dabbled in Lisp or Haskell.

   ```JavaScript
   // Make a list with x as head and xs as tail
   var cons = function(x, xs) {
       // Make a copy of xs
       var xs2 = xs.slice(0);
       xs2.unshift(x);
       return xs2;
   };
   // Return the first element of xs
   var head = function(xs) {
       return xs[0];
   };
   // Return all but the first element of xs
   var tail = function(xs) {
       return xs.slice(1);
   };
   // Return true when xs is an empty list
   var isEmpty = function(xs) {
       return xs.length == 0;
   };
   ```

   Using these primitives, we can easily define our first /higher-order
   function/. A higher-order function is a function that takes a function as
   an argument, or returns a function. The function defined below, `map` takes
   two arguments: a function `f` and an array `xs`. `map` will apply `f` to
   every element in `xs` and return a new array containing the return values
   of these applications.

   ```JavaScript
   var map = function(f, xs) {
       if (isEmpty(xs))
           return [];
       else
           return cons(f(head(xs)), map(f, tail(xs)));
   };
   map(function(x) { return x + 1; }, [1, 2, 3]); // [2, 3, 4]
   ```

   The `map` function is defined recursively. Functional programmers prefer
   recursion to iteration, mostly because iteration involves loop indexes, or
   some other form of state, but elegance also plays a role.

   >[L. Peter Deutsch] To iterate is human, to recurse divine.

   Q: Doesn't recursion lead to stack overflow errors when it goes on for too
      long?

   A: That's true, recursion comes at a cost, namely the stack space that is
      consumed by the recursive function calls. When passed a very large list,
      the `map` function will exhaust the stack and cause a stack overflow
      error. The solution for this problem is /tail call optimisation/. When a
      language, or rather a language implementation, supports tail call
      optimisation, function calls in tail position<foot>A statement or
      expression is in tail position when it's the last thing to be executed
      or evaluated before the function returns.</foot> are eliminated and
      replaced by jumps to the function, effectively transforming tail
      recursive programs<foot>The example above is actually not /tail/
      recursive, but could be made tail recursive, e.g. by the use of an
      accumulator.</foot> into equivalent programs that use loops. Although
      the Scheme<foot>Remember that Scheme was one of the main influences on
      JavaScript.</foot> standards require implementations to support tail
      call optimization, JavaScript standards don't require it.

      Because of this lack of tail call optimisation, it's recommended to
      write programs using loops instead of recursion in JavaScript.

   On the last line of the example above, you can see the `map` function in
   use: we increment each element of a list with one. You will probably have
   noticed that declaring the anonymous function that adds `1` to a value
   takes much space. Just to declare the simplest anonymous function, e.g. the
   identity function, takes at least 21 characters in JavaScript:
   `function(x){return x}`, compare this with, for example, Haskell: `\x->x`,
   only 5 characters! The unwieldiness of the `function` keyword is one of
   JavaScript's warts when it comes to writing programs using higher-order
   functions.

   Version 1.6 of JavaScript provides a built-in `map` function declared on
   the prototype of `Array`:

   ```JavaScript
   [1, 2, 3].map(function(x) { return x + 1; }); // [2, 3, 4]
   ```

   In addition to `map`, `forEach`, `every`, `some`, and `filter` are also
   available. In even more recent versions of JavaScript, `reduce` and
   `reduceRight` are available. These will ring a bell with programmers with
   Haskell or Clojure experience. This demonstrates that functional
   programming, albeit in limited form, is slowly creeping into mainstream
   languages.

   Let's look at another example, the `partial` function. Invoking `partial`
   on a function `f` with a number of arguments will return a new function,
   let's call this function `g`. When `g` is invoked, the following things
   will happen: the original arguments are concatenated with the new
   arguments, and `f` is invoked with the concatenated arguments. Three
   elements come together in this example: prototypes, the `arguments` object
   and higher-order functions.

   ```JavaScript
   Function.prototype.partial = function() {
       var args = Array.prototype.slice.call(arguments);
       // Capture this into f, so we can refer to it in the nested function
       // definition, wherein this refers to the defined function.
       var f = this;
       return function () {
           var innerArgs = Array.prototype.slice.call(arguments);
           return f.apply(this, args.concat(innerArgs));
       };
   };
   function add(x, y) { return x + y; };
   var inc = add.partial(1);
   inc(2); // 3
   ```

   The example was taken from #[FuncProgJS].

   ## Libraries ##[func-libs]

   As demonstrated in the previous section, programming in a functional style
   is certainly possible in JavaScript. Numerous programmers have discovered
   this and have even made libraries providing functions that promote
   programming in a functional style. Here are some interesting ones:

   * [Underscore.js][http://underscorejs.org]
   * [Functional JavaScript][http://osteele.com/sources/javascript/functional/]
   * [prelude.ls][http://gkz.github.com/prelude-ls/]<foot>This library is
     actually written in LiveScript, a functional language that compiles to
     JavaScript, more about such languages in #[compiling-to-js]</foot>


# Monkey-patching #[monkey-patching]

Q: When talking about JavaScript's dynamic nature, you said JavaScript was
   comparable to Ruby in this aspect. Does JavaScript also support monkey
   patching?

A: Yes, it's also possible do monkey patching in JavaScript. In Ruby, classes
   can be modified at run-time. As seen in #[proto], JavaScript allows
   objects, and by consequence classes too,<foot>Remember that classes in
   JavaScript are emulated/implemented using objects.</foot> to be modified at
   run-time. This is just the way JavaScript works. As JavaScript is executed
   line by line, objects are also created line by line, property after
   property, constantly modifying the object.

   Monkey patching is often used to modify the behaviour of third-party or
   even standard libraries without requiring access to their source. Fixing
   bugs in libraries, mocking test objects, changing the behaviour of a
   function to suit your program, extending objects with useful methods, ...
   are all reasons to monkey patch.

   In JavaScript, you can simply modify properties of objects. A more
   effective and also more radical approach is to modify the prototypes of
   objects.

   Let's extend JavaScript's built-in object with some methods:

   ```JavaScript
   // Return the last element
   Array.prototype.last = function() {
       return this[this.length - 1];
   };
   [1, 2, 3].last(); // 3

   // Capitalise the string
   String.prototype.capitalise = function() {
       var newStr = '';
       if (this.length == 0)
           return newStr;

       newStr += this[0].toUpperCase();
       for (var i = 1; i < this.length; i++)
           newStr += this[i].toLowerCase();

       return newStr;
   };
   'brendan'.capitalise(); // 'Brendan'

   // Merge two hash maps together in a new one
   Object.prototype.merge = function(obj) {
       var newObj = {};
       for (var k in this) {
           newObj[k] = this[k];
       }
       for (var k in obj) {
           newObj[k] = obj[k];
       }
       return newObj;
   };
   ({a: 1}).merge({b: 2}); // { a: 1, b: 2, merge: [Function] }
   ```

   All the methods that we added with monkey patches are quite useful. They
   seem to work correctly except for the last one: the `merge` function
   appears to have sneaked in the hash map we got back after merging the two
   hash maps. How did this happen? By adding the `merge` method to the
   prototype of `Object`, the top of the inheritance chain, /every/ object
   will inherit this property and thus have a `merge` property with as value
   the newly defined function. This is obviously an unintended side-effect.

   It turns out that we can actually hide this `merge` property, by making it
   /un/enumerable.

   ```JavaScript
   Object.defineProperty(Object.prototype, 'merge', {
           enumerable: false
   });
   ({a: 1}).merge({b: 2}); // { a: 1, b: 2 }
   ```

   Q: The apparent problem seems to be solved by hiding the properties that
      were added as monkey patches. Are there any other drawbacks to monkey
      patching?

   A: The common pitfalls of monkey patching still apply:

      * Patching a method in a single place will affect the whole program,
        which can cause some unintended behaviour. However, it is possible to
        revert or remove the monkey patched methods after using
        them.<foot>Users familiar with Lisp macros will see in the example
        below a perfect opportunity for a `with-patches` macro. The
        application and removal and the patches should be put in a try- and a
        finally-clause respectively.</foot>

        ```JavaScript
        [1, 2, 3].last(); // no method 'last'
        Array.prototype.last = function() {
            return this[this.length - 1];
        };
        [1, 2, 3].last(); // 3
        delete Array.prototype.last; // the delete operator deletes a property
        [1, 2, 3].last(); // no method 'last'
        ```

      * When a single method is monkey patched in two different places in your
        program, it's not always clear which monkey patch /wins/.

      * Monkey patching third-party libraries or the built-in objects, will
        inevitably create discrepancies between the documented and the actual
        behaviour.

      Source: #[MonkeyPatch]

      The example with the `merge` monkey patch is actually still not correct,
      consider the following case:

      ```JavaScript
      ({a: 1, merge: 3}).merge({b: 2});
      // TypeError: Property 'merge' of object #<Object> is not a function
      ```

      Objects are the easiest way to emulate hash maps in JavaScript, but as
      soon as the prototype of `Object` is monkey patched, objects can no
      longer be used safely as hash maps. As you saw in the example above,
      keys with the same name as a monkey patched method will break the
      behaviour of the hash map and the monkey patched method.

   Q: Given the pitfalls just listed, is monkey patching still encouraged in
      JavaScript or rather frowned upon?

   A: If done with care and for the right reasons, monkey patching is a
      defensible solution. Fixing a bug in a third-party library could be a
      valid reason, provided that the monkey patch will only be applied to
      faulty versions of the library.
