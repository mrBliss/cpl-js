<!DOCTYPE HTML>

<html>
  <head>
    <meta charset="UTF-8">
    <title>CPL Assignment 1: JavaScript</title>
    <link href="http://fonts.googleapis.com/css?family=Inconsolata:400,700|Crimson+Text:400,400italic,700,700italic" rel="stylesheet" type="text/css">
    <link rel="stylesheet/less" href="styles.less" type="text/css" media="screen" />
    <link rel="stylesheet" href="codemirror.css" type="text/css" media="screen" />
    <script type="text/javascript" src="js/jquery.min.js"></script>
    <script type="text/javascript" src="js/less-1.3.1.min.js"></script>
    <script type="text/javascript" src="js/codemirror.js"></script>
    <script type="text/javascript" src="js/javascript.js"></script>
    <script type="text/javascript" src="js/clike.js"></script>
    <script type="text/javascript" src="js/parse-js.js"></script>
    <script type="text/javascript" src="js/process.js"></script>
    <script type="text/javascript" src="js/formatter.js"></script>
  </head>

  <body name="top">
    <div id="scroller">
      <a href="#top">&uarr; To top</a>
    </div>
    <div id="info">
      <div class="leftCol">
        <div id="header">
          <h1>CPL<br>Assignment 1</h1>
          <h2>JavaScript</h2>
        </div>
        <div id="credits">Â© 2012 Glenn Croes, Philippe De Croock, Thomas Winant</div>
      </div>
      <div id="toc" class="rightCol">
        <ol start="0">
          <li class="unnumbered"><a href="#introduction">Introduction</a>
            <li><a href="#semantics">Semantics</a>
<ol>
<li><a href="#object-oriented-programming">Object-oriented programming</a>
<ol>
<li><a href="#objects">Objects</a></li>
<li><a href="#prototype-based-programming">Prototype-based programming</a></li>
<li><a href="#encapsulation">Encapsulation</a></li>
<li><a href="#closures">Closures</a></li>
<li><a href="#polymorphism">Polymorphism</a></li>
<li><a href="#function-arguments">Function arguments</a></li>
<li><a href="#modularity">Modularity</a></li>
</ol>
</li>
<li><a href="#functional-programming">Functional programming</a></li>
</ol>
</li>

          <li class="unnumbered"><a href="#bibliography">Bibliography</a></li>
        </ol>
      </div>
    </div>
    <span class="spacer"></span>
    <h3 name="introduction">Introduction</h3>
    <p>Lorem ipsum dolor sit amet, consectetur adipisicing elit, sed do eiusmod tempor incididunt ut labore et dolore magna aliqua. Ut enimad minim veniam, quis nostrud exercitation ullamco laboris nisi ut aliquip ex ea commodo consequat. Duis aute irure dolor in reprehenderit in voluptate velit esse cillum dolore eu fugiat nulla pariatur. Excepteur sint occaecat cupidatat non proident, sunt in culpa qui officia deserunt mollit anim id est laborum.</p>


    <h3><a name="semantics"></a>I. Semantics</h3>
<h4><a name="object-oriented-programming"></a>I.1. Object-oriented programming</h4>
<div class="question">I&rsquo;ve heard that JavaScript is an object-oriented language, could you expand on that?</div>
<div class="answer">
<p>Indeed, JavaScript is object-oriented. Typically, in object-oriented languages, everything is an object (e.g. Python, Scala, Ruby, Eiffel, &hellip;) In JavaScript this is not the case, there are both objects and primitives. The primitives in JS are numbers, strings, booleans, and the special types null and undefined. The objects include <code>Array</code>, <code>Function</code>, <code>Date</code>, <code>RegExp</code>, <code>Error</code>, &hellip; This design decision, by many people considered a mistake, was carried over from Java.</p>
<h5><a name="objects"></a>I.1.1. Objects</h5>
<p>Objects in JavaScript are in fact containers of properties, where each property has a name and a value. By assigning a function to a property&rsquo;s value, one can add a method to the object. This demonstrates the importance of the presence of first-class functions. Objects in JavaScript can be compared with untyped hashmaps from strings to values from any kind. Then name of a property can be any string, but the quotes can be dropped if the name of the property is a valid JavaScript identifier. The quotes are required when the property name is a reserved keyword, an empty string, or other strings not constituting valid JavaScript identifiers.</p>
<pre>var emptyObject = {};
var person = {
    name: "Erin",
    age: 28,
    "place-of-birth": "Gibraltar", // hyphens are not allowed in JavaScript identifiers
    walk: function () { return "Do bi do ... walking, walking, walking"; }
};</pre>
<p>Property lookup is done via the <code>.</code> notation. When the property name is not a valid JavaScript identifier, one has to use the bracket notation. Looking up a property of which the value is a function, just returns that function. To actually invoke it, terminate the expression with <code>()</code>.</p>
<pre>person.name; // "Erin"
person["place-of-birth"]; // "Gibraltar"
person.walk; // [Function]
person.walk(); // "Do bi do ... walking, walking, walking"</pre>
<p>This notation of objects is compact, easy to parse and parse, and has become a popular general data-interchange format, called JSON (JavaScript Object Notation). TODO expand on JSON</p></div>
<div class="question">Object-oriented programming includes more than &ldquo;everything is an object&rdquo;. What about polymorphism, inheritance, etc.?</div>
<div class="answer">
<p>Of course, OOP is broader than &ldquo;everything is an object&rdquo;. Most definitions of object-oriented programming include features such as modularity, encapsulation, polymorphism, inheritance, &hellip;</p>
<p>JavaScript has support most of them, but differs from other classical OO languages in the implementation of these features. Take for instance inheritance. Classical OO languages mostly feature a class-based inheritance mechanism, whereas JavaScript has prototype-based inheritance. JavaScript often has a different way of doing things compared to other languages, this will be a recurring theme.</p>
<h5><a name="prototype-based-programming"></a>I.1.2. Prototype-based programming</h5>
<div class="question">What entails prototype-based inheritance?</div>
<div class="answer">
<p>A better term would be prototype-based programming, as inheritance is just one non-mandatory ingredient of this style of object-oriented programming. Prototype-based programming can easily be explained by comparing it with class-based programming.</p>
<p>In class-based programming, one defines classes. Each class consists of fields and methods. To use a class, one creates a new object of the class, which will have the fields and methods defined in the class. Let&rsquo;s make an analogy: the class is the blueprint of the car, and the objects are cars built from the blueprint. Now let&rsquo;s throw inheritance in the mix. One can define a class that inherits from another class. This new class will contain all the fields and methods of the parent class, but can add fields and methods, and can also override fields and methods.</p>
<p>In prototype-based programming, one defines objects. Each object will consist of fields and methods, or in JavaScript&rsquo;s case, properties. The whole concept of classes is removed from the equation. Instead of defining a blueprint to build new cars with, one just builds a car. But does this mean that we have to build every car from scratch, i.e. (re)define the fields and methods for every objects we want to use? No, to make a new object with the same fields and methods as another object, we <emph>clone</emph> the old object to get a new one. In other terms: we define a new object with the old object as prototype. Inheritance is also done via cloning, but after the cloning, the new object is extended with new fields and/or methods, and existing fields and/or methods can also be overriden. This new object can, in turn, be used as a prototype for other objects.</p>
<div class="question">Could you show how it&rsquo;s done in JavaScript?</div>
<div class="answer">
<p>In JavaScript, objects can be created via object literal. In this case, <code>Object</code> will be their prototype.</p>
<pre>var o = {foo: "bar"};
// Object.getPrototypeOf(x) returns the prototype of x
Object.getPrototypeOf(o); // {}, which is an empty Object</pre>
<p>Another way to create objects in JavaScript, is via the <code>new</code> keyword, which you probably know from C++, Java, etc. The <code>new</code> keyword should be followed by a function call. The function after the <code>new</code> keyword is called the constructor. Objects created this way will have their constructor&rsquo;s prototype as their prototype.</p>
<pre>// Car is a constructor
function Car(make) {
    this.make = make;
};
Object.getPrototypeOf(Car); // [Function: Empty] is the prototype of a function
// Define a new method for Car
Car.prototype.drive = function() {
    println("Vroom");
};
var myCar = new Car("BMW");
Object.getPrototypeOf(myCar); // { drive: [Function] }, the prototype of Car</pre>
<p>Notice that the name of the constructor function is capitalized, this is convention, carried over from Java.</p>
<div class="question">If the naming is only a convention, how then differs a constructor from a regular function?</div>
<div class="answer">
<p>It doesn&rsquo;t actually, it&rsquo;s the use of <code>new</code> that makes a regular function act like a constructor. By prepending this keyword, a couple of things happen.</p>
<ul>
<li>A new object is created, accessible via <code>this</code>.</li>
<li>The constructor function is invoked on this object. TODO refer to caller contexts.</li>
<li>The prototype of the constructor function is stored as the prototype of the new object.</li>
<li>The newly created object is automatically returned at the end of the function call.</li>
</ul></div>
<p>Here&rsquo;s another example of inheritance in JavaScript.</p>
<pre>// Create a new object that inherits from obj
function inherit(obj) {
    function f() {}; // Dummy constructor
    // The new object's prototype is obj
    f.prototype = obj;
    // Make the new object
    return new f();
}
// Create a new object from scratch
var a = {x: "a's x"};
// Create a new object by cloning an existing object
var b = inherit(a);
// Change the value of b's x property
b.x = "b's x";
// This change only affects b
a.x; // "a's x"
b.x; // "b's x"</pre></div>
<div class="question">What are the pros and cons of prototype-based programming?</div>
<div class="answer">
<p>Prototype-based programming gives the programmer more flexibility and freedom to define and redefine the fields and methods of objects dynamically. Instead of focusing on building a brittle taxonomy of classes, as in class-based programming, the focus lies on making a set of objects with the desired behaviour, reusing them via cloning, and modifying their behaviour when it&rsquo;s required. When building a taxonomy, it is often the case that some class at the bottom of the chain inherited some unwanted fields or methods, as it is not always possible to classify everything in a consistent taxonomy. Prototype-based programming gives you the freedom to clone and override the fields and methods of other objects at will.</p>
<p>For example, you have a bunch of <code>Cat</code> objects, but you want one of the cats, named Dexter, to make a different meow-sound. You can simply change the <code>meow</code> method of Dexter, a single <code>Cat</code> object, without affecting the others, or having to define a new subclass of <code>Cat</code>.</p>
<p>Having so much control over which fields and methods to <emph>inherit</emph> allows the programmer to do things not possible in class-based languages without language support, for instance traits can easily be emulated using prototype-based programming. Even classes can be and often are emulated.</p>
<p>Let&rsquo;s show you how to emulate classes using prototypes:</p>
<pre>function Car(make) {
    this.make = make;
};
Car.prototype.drive = function() {
    println("Vroom");
};
// Constructor for the subclass SportsCar
function SportsCar(make) {
    this.make = make;
};
// The prototype of SportsCar is a regular Car
SportsCar.prototype = new Car();
// We change the constructor, because we inherited Car's constructor
SportsCar.prototype.constructor = SportsCar;
SportsCar.prototype.driveFast = function() {
    this.drive(); this.drive();
};

// Instantiate a new SportsCar
var mySportsCar = new SportsCar("BMW");
mySportsCar.driveFast();
// Vroom
// Vroom</pre>
<p>The steps to create a subclass are often put together in a single function, allowing easy class-based inheritance.</p>
<p>Traits are also easy to emulate, although we don&rsquo;t have access to the super objects anymore. Abstract members can also be emulated, but will not be checked at compile-time for presence.</p>
<pre>// The Trait we define
var HasTires = {
    tiresOk: true,
    puncture: function() {
        this.tiresOk = false;
    }
};
// Add the properties of the trait to the prototype of obj
var mixin = function(obj, trait) {
    for (var prop in trait) {
        obj.prototype[prop] = trait[prop];
    }
};
// We'll continue with the SportsCar defined above
mixin(SportsCar, HasTires);
// The already defined mySportsCar now has the functionality defined in
//  the HasTires trait
mySportsCar.puncture();
mySportsCar.tiresOk; // false</pre>
<p>Of course, freedom comes with a price. One of the disadvantages are the slower field and method accesses/dispatches and to a lesser extend the memory overhead. Objects cloned from others object don&rsquo;t clone the fields and methods. It would be wasteful to clone this reusable data. Instead, the cloned object keeps track of its prototype. Whenever an inherited field or method of the new object, i.e. a field or method defined in the prototype (or a prototype of the prototype), is accessed, the new object delegates the call to the prototype. This delegation will go on until a definition is found in one of the ancestor prototypes. The longer this <emph>chain</emph> of prototypes, the costlier a field access or method call.</p>
<p>Another disadvantage is that it becomes harder to figure out which fields and methods an object has, and where they were defined. When using classes, knowing the class of an object is enough to know which fields and methods an object has (this, of course, includes looking at superclasses). A class functions as the type of the object, but in JavaScript, properties can be added and removed from objects at run-time.</p>
<p>http://en.wikipedia.org/wiki/Prototype-based_programming</p></div></div>
<p>TODO mention caller contexts p284, this</p>
<h5><a name="encapsulation"></a>I.1.3. Encapsulation</h5>
<p>Another example of JavaScript&rsquo;s <emph>exotic</emph> way of doing things is encapsulation. Most classical OO languages support visibility modifiers to control the accessibility of fields and methods by other classes. In JavaScript, there are no such modifiers, but encapsulation is still achievable, via the use of closures.</p>
<p>Example:</p>
<pre class="Java">class A {
    private int counter = 0;
    public void inc() {
        counter++;
    }
}
..
A a = new A();
a.inc(); // OK
a.counter; // Error: not visible!
..</pre>
<pre>var a = (function () {
    var counter = 0;
    return {
        inc: function() {
            counter++;
        },
    };
})();
a.inc(); // OK
a.counter; // Error: not visible!</pre>
<h5><a name="closures"></a>I.1.4. Closures</h5>
<p>Q: What is a closure? A: TODO p 310</p>
<div class="question">What are the advantages of implementing encapsulation via closures?</div>
<div class="answer">
<p>Actually, one could call it <emph>emulating</emph> encapsulation via closures. Because of the absence of encapsulation, JavaScript programmers are required to implement encapsulation manually via closures. So one could call it a disadvantage of JavaScript, although some people argue against encapsulation.</p>
<p>With closures, the programmer has more control over encapsulation, but has to do more work to achieve it.</p></div>
<h5><a name="polymorphism"></a>I.1.5. Polymorphism</h5>
<p>Polymorphism in JavaScript is achieved via inheritance.</p>
<p>Example:</p>
<pre>// Superclass Animal
var Animal = function(name) { this.name = name; };
// Default implementation of makeNoise
Animal.prototype.makeNoise = function() { return "Silence"; };

// Subclass Dog
var Dog = function(name) { this.name = name; };
Dog.prototype = new Animal();
// Override makeNoise
Dog.prototype.makeNoise = function() { return "Bark"; };

// Subclass Turtle
var Turtle = function(name) { this.name = name; };
// Don't override makeNoise
Turtle.prototype = new Animal();

var animals = [new Dog("Pluto"), new Turtle("Jeffrey")];

for (var i = 0; i < animals.length; i++) {
    println(animals[i].makeNoise());
}
// Bark
// Silence</pre>
<div class="question">You mentioned that one can <emph>override</emph> a method in JavaScript, is also possible to overload a method in JavaScript?</div>
<div class="answer">
<p>To be clear, a method (or function) overloads another method if it has the same name, but differs in the number of arguments or the types of the expected arguments. The right method to call is chosen statically, at compile-time. Overloading is a feature typically present in statically typed languages. With JavaScript being a dynamically typed language, the compile-time resolution that determines which method to call is ruled out, as the types are not known in advance.</p>
<h5><a name="function-arguments"></a>I.1.6. Function arguments</h5>
<p>Overloading based on arity is possible in dynamically typed languages, but not in JavaScript. The reason being that JavaScript doesn&rsquo;t check whether a function is called with the correct number of arguments. JavaScript will happily allow you to call a function expecting two arguments with 0, 1, 2, 3, &hellip; arguments. Missing arguments will be <code>undefined</code>. JavaScript also allows you to access the excess arguments via the <code>arguments</code> object. The <code>arguments</code> object is a local variable accessible within all functions. It is similar to an Array, but not quite the same. The elements of <code>arguments</code> can be accessed, and it has the <code>length</code>-property, but the other methods available for <code>Array</code>s cannot be used on the <code>arguments</code> object. One can convert the <code>arguments</code> object to an actual array, by calling <code>Array</code>&lsquo;s <code>slice</code>-method on it, like so: <code>var args = Array.prototype.slice.call(arguments);</code>.<span class="footnote">The <code>slice</code>-method of <code>Array</code> copies the elements into a new array, it optionally takes start- and end-indices.</span></p>
<p>Source: https://developer.mozilla.org/en-US/docs/JavaScript/Reference/Functions_and_function_scope/arguments</p>
<p>TODO default parameters (compare with CL?)</p>
<div class="question">What&rsquo;s the point of this <code>arguments</code> object? And why isn&rsquo;t it a proper <code>Array</code>?</div>
<div class="answer">
<p>The <code>arguments</code> object allows the programmer to define methods expecting a variable number of arguments.</p>
<p>Example:</p>
<pre>// Sums all its arguments. The argument list is empty, because we'll
// use the arguments object.
function addAll() {
    var args = Array.prototype.slice.call(arguments);
    var total = 0;
    // args.shift() removes the first element from the array, and
    // returns that element.
    while (args.length > 0) total += args.shift();
    return total;
}</pre>
<p>Even when expecting a fixed number of arguments, the programmer can benefit from access to the <code>arguments</code> object. For instance when implementing a decorator.</p>
<pre>function decorate(toDecorate, decorator) {
    return function() {
        // Both the decorator and the function to decorate can be
        // called with the same arguments.
        decorator.apply(null, arguments);
        return toDecorate.apply(null, arguments);
    };
};

function argsPrinter() {
    var args = Array.prototype.slice.call(arguments);
    println("Arguments: " + args.join(", "));
};

function add(x, y) { return x + y; };

decorate(add, argsPrinter)(1, 2);
// Arguments: 1, 2
// => 3</pre></div>
<p>JavaScript&rsquo;s loose call convention, and the presence of the <code>arguments</code> object allows the programmer to emulate overloading by doing the resolution at run-time.</p>
<p>Example:</p>
<pre class="Java">void overloaded() { return "No args"; }
void overloaded(int x) { return "A number"; }
void overloaded(String x) { return "A string"; }
void overloaded(int x, String y) { return "A number and a string"; }</pre>
<pre>function overloaded(arg1, arg2) {
    // One could also use an if-then-else construction
    switch (arguments.length) {
    case 0: return "No args"; break;
    case 1: switch (typeof(arg1)) {
            case 'number': return "A number"; break;
            case 'string': return "A string"; break;
            }
            break;
    case 2: if (typeof(arg1) == 'number' && typeof(arg2) == 'string')
                return "A number and a string";
    }
}
// Identical for the Java program
overloaded();
// No args
overloaded(1);
// A number
overloaded("foo");
// A string
overloaded(1, "foo");
// A number and a string</pre>
<p>These <code>return</code>-statements could of course be replaced with different blocks of code, specific for each case.</p></div>
<h5><a name="modularity"></a>I.1.7. Modularity</h5>
<p>TODO Modularity in JavaScript p 306</p></div>
<h4><a name="functional-programming"></a>I.2. Functional programming</h4>
<p>TODO functional programming p 331</p>

    <div id="bibliography" name="bibliography">
      <h3 name="bibliography">Bibliography</h3>
      <ol>
        <li class="book"><span class="author">Abelson, H., & Sussman, G.J.</span> <span class="year">(1984)</span>. <span class="title">Structure and Interpretation of Computer Programs</span>. <span class="publisher-address">Cambridge, MA</span>: <span class="publisher">MIT Press</span>.</li>
        <li class="blog"><span class="authors">Buckler, C.</span> (October 10, 2012). <span class="title">How to Create Custom Events in JavaScript</span>. Message posted to <a href="http://jspro.com/raw-javascript/how-to-create-custom-events-in-javascript/">http://jspro.com/raw-javascript/how-to-create-custom-events-in-javascript/</a></li>
        <li class="blog"><span class="authors">Buckler, C.</span> (December 1, 2010). <span class="title">JavaScript Execution and Browser Limits</span>. Message posted to <a href="http://www.sitepoint.com/javascript-execution-browser-limits/">http://www.sitepoint.com/javascript-execution-browser-limits/</a></li>
        <li class="blog"><span class="authors">Cornford, R.</span> (March, 2004). <span class="title">Javascript Closures</span>. Message posted to <a href="http://jibbering.com/faq/notes/closures/">http://jibbering.com/faq/notes/closures/</a></li>
        <li class="blog"><span class="authors">Crockford, D.</span> (2001). <span class="title">JavaScript: The World's Most Misunderstood Programming Language</span>. Message posted to <a href="http://javascript.crockford.com/javascript.html">http://javascript.crockford.com/javascript.html</a></li>
        <li class="book"><span class="author">Crockford, D.</span> <span class="year">(2008)</span>. <span class="title">JavaScript: The Good Parts</span>. <span class="publisher-address">Sebastopol, CA</span>: <span class="publisher">O'Reilly Media</span>.</li>
        <li class="blog"><span class="authors">Crockford, D.</span> <span class="title">The Little JavaScripter</span>. Message posted to <a href="http://crockford.com/javascript/little.html">http://crockford.com/javascript/little.html</a></li>
        <li class="blog"><span class="authors">De Rosa, A.</span> (October 15, 2012). <span class="title">Five Useful Functions Missing in JavaScript</span>. Message posted to <a href="http://jspro.com/raw-javascript/5-useful-functions-missing-in-javascript/">http://jspro.com/raw-javascript/5-useful-functions-missing-in-javascript/</a></li>
        <li class="blog"><span class="authors">Edwards, J.</span> (October 15, 2012). <span class="title">Modular Design Patterns: Private, Privileged, and Protected Members in JavaScript</span>. Message posted to <a href="http://jspro.com/raw-javascript/modular-design-patterns-in-javascript/">http://jspro.com/raw-javascript/modular-design-patterns-in-javascript/</a></li>
        <li class="blog"><span class="authors">Eich, B.</span> (April 3, 2008). <span class="title">Popularity</span>. Message posted to <a href="https://brendaneich.com/2008/04/popularity/">https://brendaneich.com/2008/04/popularity/</a></li>
        <li class="blog"><span class="authors">Eich, B.</span> (July 21, 2010). <span class="title">A Brief History of JavaScript</span>. Message posted to <a href="https://brendaneich.com/2010/07/a-brief-history-of-javascript/">https://brendaneich.com/2010/07/a-brief-history-of-javascript/</a></li>
        <li class="book"><span class="author">Flanagan, D.</span> <span class="year">(2011)</span>. <span class="title">JavaScript: The Definitive Guide</span> <span class="edition">(6th ed.)</span>. <span class="publisher-address">Sebastopol, CA</span>: <span class="publisher">O'Reilly Media</span>.</li>
        <li class="blog"><span class="authors">Rauschmayer, A.</span> (December 17, 2011). <span class="title">Fake operator overloading in JavaScript</span>. Message posted to <a href="http://www.2ality.com/2011/12/fake-operator-overloading.html">http://www.2ality.com/2011/12/fake-operator-overloading.html</a></li>
        <li class="blog"><span class="authors">Tetlaw, A.</span> (November 11, 2008). <span class="title">arguments: A JavaScript Oddity</span>. Message posted to <a href="http://www.sitepoint.com/arguments-a-javascript-oddity/">http://www.sitepoint.com/arguments-a-javascript-oddity/</a></li>
        <li class="blog"><span class="authors">Willison, S.</span> (March 7, 2006). <span class="title">A re-introduction to JavaScript (JS Tutorial)</span>. Message posted to <a href="https://developer.mozilla.org/en-US/docs/JavaScript/A_re-introduction_to_JavaScript">https://developer.mozilla.org/en-US/docs/JavaScript/A_re-introduction_to_JavaScript</a></li>
        <li class="blog"><span class="authors">Wilton-Jones, M.</span> <span class="title">JavaScript History</span>. Message posted to <a href="http://www.howtocreate.co.uk/jshistory.html">http://www.howtocreate.co.uk/jshistory.html</a></li>
        <li class="website"><span class="siteName">About.com</span>. <span class="title">A Brief History of Javascript</span>. Retrieved November 3, 2012, from <a href="http://javascript.about.com/od/reference/a/history.htm">http://javascript.about.com/od/reference/a/history.htm</a></li>
        <li class="encyc"><span class="title">ECMAScript</span>. In <span class="encyc">Wikipedia</span>. Retrieved November 3, 2012, from <a href="http://en.wikipedia.org/wiki/ECMAScript">http://en.wikipedia.org/wiki/ECMAScript</a></li>
        <li class="encyc"><span class="title">ECMAScript Syntax</span>. In <span class="encyc">Wikipedia</span>. Retrieved November 3, 2012, from <a href="http://en.wikipedia.org/wiki/ECMAScript_syntax">http://en.wikipedia.org/wiki/ECMAScript_syntax</a></li>
        <li class="website"><span class="siteName">JSON</span>. <span class="title">Introducing JSON</span>. <a href="http://www.json.org">http://www.json.org</a></li>
        <li class="website"><span class="siteName">Mozilla Developer Network</span>. (2012). <span class="title">JavaScript - Reference - Functions and function scope - arguments</span>. Retrieved November 3, 2012, from <a href="https://developer.mozilla.org/en-US/docs/JavaScript/Reference/Functions_and_function_scope/arguments">https://developer.mozilla.org/en-US/docs/JavaScript/Reference/Functions_and_function_scope/arguments</a></li>
        <li class="encyc"><span class="title">JavaScript History</span>. In <span class="encyc">Wikipedia</span>. Retrieved November 3, 2012, from <a href="http://en.wikipedia.org/wiki/JavaScript#History">http://en.wikipedia.org/wiki/JavaScript#History</a></li>
        <li class="website"><span class="siteName">About.com</span>. <span class="title">JavaScript and JScript: What's the Difference?</span>. Retrieved November 3, 2012, from <a href="http://javascript.about.com/od/reference/a/jscript.htm">http://javascript.about.com/od/reference/a/jscript.htm</a></li>
        <li class="website"><span class="siteName">WebScanNotes.com</span>. (2012). <span class="title">Javascript Semantics for Computer Scientists</span>. Retrieved November 3, 2012, from <a href="http://webscannotes.com/2012/06/19/javascript-semantics-for-computer-scientists-part-1-variables-and-scope/">http://webscannotes.com/2012/06/19/javascript-semantics-for-computer-scientists-part-1-variables-and-scope/</a></li>
        <li class="website"><span class="siteName">Dev.Opera</span>. (2008). <span class="title">MAMA: Key findings</span>. Retrieved November 3, 2012, from <a href="http://dev.opera.com/articles/view/mama-key-findings/">http://dev.opera.com/articles/view/mama-key-findings/</a></li>
        <li class="encyc"><span class="title">Prototype-based programming</span>. In <span class="encyc">Wikipedia</span>. Retrieved November 1, 2012, from <a href="http://en.wikipedia.org/wiki/Prototype-based_programming">http://en.wikipedia.org/wiki/Prototype-based_programming</a></li>
        <li class="website"><span class="siteName">Google Developers</span>. (2012). <span class="title">V8 Introduction</span>. <a href="https://developers.google.com/v8/intro">https://developers.google.com/v8/intro</a></li>
        <li class="website"><span class="siteName">Dev.Opera</span>. (2009). <span class="title">What can you do with JavaScript?</span>. Retrieved November 3, 2012, from <a href="http://dev.opera.com/articles/view/javascript-uses/">http://dev.opera.com/articles/view/javascript-uses/</a></li>
      </ol>
    </div>

  </body>
</html>
